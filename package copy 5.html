<!doctype html>
<html lang="zh-Hant">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width,initial-scale=1" />
    <title>è‹”ç™¬èˆ‡è˜‘è‡ç”Ÿæ…‹åˆ†å¸ƒç¤ºæ„ï¼ˆé«˜åº¦æ¼¸å±¤ç‰ˆï¼‰</title>
    <style>
      html, body { height: 100%; margin: 0; background: #ffffff; }
      canvas { display: block; }
      #info {
        position: absolute;
        top: 10px;
        left: 10px;
        font-family: Arial, sans-serif;
        background: rgba(255,255,255,0.85);
        padding: 6px 10px;
        border-radius: 6px;
        font-size: 13px;
        line-height: 1.5;
        box-shadow: 0 2px 5px rgba(0,0,0,0.1);
      }
    </style>
    <script type="importmap">
      {
        "imports": {
          "three": "https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.module.js",
          "three/examples/jsm/controls/OrbitControls": "https://cdn.jsdelivr.net/npm/three@0.160.0/examples/jsm/controls/OrbitControls.js"
        }
      }
    </script>
  </head>
  <body>
    <div id="info">
      <b>ğŸŸ¢ è‹”ç™¬</b>ï¼šé«˜åœ°ãƒ»åŒ—å¡ãƒ»é™¡æ–œãƒ»å‡¹é™·<br>
      <b>ğŸ”´ è˜‘è‡</b>ï¼šä½åœ°ãƒ»å—å¡ãƒ»å¹³ç·©ãƒ»å‡¸èµ·<br>
      åœ°å½¢é¡è‰²ï¼é«˜åº¦æ¼¸å±¤ï¼ˆä½åœ°è— â†’ é«˜åœ°æ©™ç´…ï¼‰<br>
      æ»‘é¼ æ‹–æ›³æ—‹è½‰ã€æ»¾è¼ªç¸®æ”¾
    </div>
    <script type="module">
      import * as THREE from "three";
      import { OrbitControls } from "three/examples/jsm/controls/OrbitControls";

      // === Renderer ===
      const renderer = new THREE.WebGLRenderer({ antialias: true });
      renderer.setSize(window.innerWidth, window.innerHeight);
      renderer.setPixelRatio(window.devicePixelRatio);
      document.body.appendChild(renderer.domElement);

      // === Scene & Camera ===
      const scene = new THREE.Scene();
      scene.background = new THREE.Color(0xf5f5f5);
      const camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 200);
      camera.position.set(45, 30, 45);
      const controls = new OrbitControls(camera, renderer.domElement);
      controls.enableDamping = true;

      // === Lights ===
      scene.add(new THREE.HemisphereLight(0xffffff, 0xaaaaaa, 0.7));
      const dir = new THREE.DirectionalLight(0xffffff, 1.0);
      dir.position.set(30, 50, 10);
      scene.add(dir);

      // === åœ°å½¢ ===
      const W = 120, D = 120, SEG = 200;
      const geo = new THREE.PlaneGeometry(W, D, SEG, SEG);
      geo.rotateX(-Math.PI / 2);

      function noise(x, z) {
        return (
          Math.sin(x * 0.1) +
          Math.cos(z * 0.12) +
          Math.sin((x + z) * 0.07) +
          Math.sin(x * 0.25 + z * 0.18)
        ) * 0.6;
      }

      const pos = geo.attributes.position;
      let yMin = Infinity, yMax = -Infinity;
      for (let i = 0; i < pos.count; i++) {
        const x = pos.getX(i);
        const z = pos.getZ(i);
        const y = noise(x, z) * 5;
        pos.setY(i, y);
        yMin = Math.min(yMin, y);
        yMax = Math.max(yMax, y);
      }
      geo.computeVertexNormals();

      // === é«˜åº¦é¡è‰²æ¼¸å±¤ ===
      const colors = [];
      for (let i = 0; i < pos.count; i++) {
        const y = pos.getY(i);
        const hNorm = (y - yMin) / (yMax - yMin); // normalize 0~1
        const c = new THREE.Color();
        // æ¼¸å±¤ï¼šä½åœ°â†’è—ï¼Œé«˜åœ°â†’ç´…æ©™
        c.setHSL(0.6 - 0.6 * hNorm, 0.8, 0.5);
        colors.push(c.r, c.g, c.b);
      }
      geo.setAttribute("color", new THREE.Float32BufferAttribute(colors, 3));
      const mat = new THREE.MeshLambertMaterial({ vertexColors: true });
      const terrain = new THREE.Mesh(geo, mat);
      scene.add(terrain);

      // === ç”Ÿæ…‹æ¢ä»¶ ===
      const MOSS = { height: 0.7, slope: 30, aspectCenter: 0, aspectRange: 30, color: 0x00aaff };
      const MUSH = { height: 0.3, slope: 10, aspectCenter: 180, aspectRange: 30, color: 0xff4444 };

      function calcNormal(i) {
        const n = new THREE.Vector3();
        n.fromBufferAttribute(geo.attributes.normal, i);
        const slope = Math.acos(n.y) * 180 / Math.PI;
        const aspect = (Math.atan2(n.x, n.z) * 180 / Math.PI + 360) % 360;
        return { slope, aspect };
      }
      function angleDiff(a, b) {
        let d = Math.abs(a - b) % 360;
        return d > 180 ? 360 - d : d;
      }

      const mossPos = [], mushPos = [];
      for (let i = 0; i < pos.count; i++) {
        const x = pos.getX(i);
        const y = pos.getY(i);
        const z = pos.getZ(i);
        const { slope, aspect } = calcNormal(i);
        const hNorm = (y - yMin) / (yMax - yMin);
        const rand = Math.random();

        // è‹”ç™¬
        if (
          hNorm >= MOSS.height - 0.05 * rand &&
          slope >= MOSS.slope - 5 * rand &&
          angleDiff(aspect, MOSS.aspectCenter) <= MOSS.aspectRange + 10 * rand
        ) {
          if (Math.random() < 0.55)
            mossPos.push(x + (Math.random() - 0.5) * 0.6, y + 0.3, z + (Math.random() - 0.5) * 0.6);
        }

        // è˜‘è‡
        if (
          hNorm <= MUSH.height + 0.05 * rand &&
          slope <= MUSH.slope + 5 * rand &&
          angleDiff(aspect, MUSH.aspectCenter) <= MUSH.aspectRange + 10 * rand
        ) {
          if (Math.random() < 0.55)
            mushPos.push(x + (Math.random() - 0.5) * 0.6, y + 0.3, z + (Math.random() - 0.5) * 0.6);
        }
      }

      function makePoints(arr, color, size) {
        const g = new THREE.BufferGeometry();
        g.setAttribute("position", new THREE.Float32BufferAttribute(arr, 3));
        const m = new THREE.PointsMaterial({
          color, size, sizeAttenuation: true, transparent: true, opacity: 0.9
        });
        return new THREE.Points(g, m);
      }

      const mossPts = makePoints(mossPos, MOSS.color, 1.3);
      const mushPts = makePoints(mushPos, MUSH.color, 1.3);
      scene.add(mossPts);
      scene.add(mushPts);

      // === Grid Helper ===
      const grid = new THREE.GridHelper(W, 20, 0xaaaaaa, 0xcccccc);
      grid.position.y = -0.01;
      scene.add(grid);

      // === Render ===
      function animate() {
        controls.update();
        renderer.render(scene, camera);
        requestAnimationFrame(animate);
      }
      animate();

      window.addEventListener("resize", ()=>{
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
      });
    </script>
  </body>
</html>
