<!doctype html>
<html lang="ko">
  <head>
    <!-- HTML 보일러플레이트: 문서 정보 -->
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width,initial-scale=1" />
    <title>MaskingBlending</title>

    <style>
      html,
      body {
        height: 100%;
        margin: 0;
      } /* 브라우저 화면 전체(html, body)를 100% 높이로 사용 */
      body {
        overflow: hidden; /* 스크롤바다 나타나지 않게 함 */
        background: #ffffff; /* 배경색을 흰색으로 지정 */
      }
      canvas {
        display: block; /* 캔버스 주변 여백 없앰 */
      }
    </style>

    <!-- 모듈 이름과 실제 파일 경로(URL)를 매핑해주는 설정표 -->
    <script type="importmap">
      {
        "imports": {
          "three": "https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.module.js",
          "three/examples/jsm/controls/OrbitControls": "https://cdn.jsdelivr.net/npm/three@0.160.0/examples/jsm/controls/OrbitControls.js"
        }
      }
    </script>
  </head>

  <body>
    <!-- three.js 보일러플레이트 시작 -->
    <!-- 위에서 정의한 importmap을 실제로 불러와서 사용하는 코드 -->
    <script type="module">
      import * as THREE from "three";
      import { OrbitControls } from "three/examples/jsm/controls/OrbitControls";

      // 1) Renderer
      const renderer = new THREE.WebGLRenderer({ antialias: true });
      // WebGLRenderer: 브라우저의 WebGL API를 이용해 3D 장면을 그려주는 엔진
      // {anialias: true}: jagged edges를 줄이기 위한 안티앨리어싱 옵션
      renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2)); // 화면 픽셀 비율을 맞춤
      // 브라우저가 보고 있는 CSS 픽셀과 물리 픽셀 비율을 2(레티아 디스플레이)까지만 허용한다.
      // 1(일반 모니터), 2(레티나 디스플레이), 3-(4K/8K...)
      renderer.setSize(window.innerWidth, window.innerHeight);
      // 렌더러 캔버스의 크기를 브라우저 창 크기에 맞춘다.
      renderer.setClearColor(0xffffff, 1);
      // 배경을 흰색으로 지정하고, 투명도는 1(완전 불투명)
      renderer.shadowMap.enabled = true;
      renderer.outputColorSpace = THREE.SRGBColorSpace;
      document.body.appendChild(renderer.domElement);
      // three.js가 내부에서 만든 캔버스(renderer.domElement)를 HTML 문서에 추가해서, 실제로 화면에 3D 장면이 그려지도록 하는 코드.

      // 2) Scene
      const scene = new THREE.Scene();
      // 3D 그래픽을 담을 stage 같은 공간 생성
      // scened은 프로젝트에서 가장 상위 컨테이너 역할

      // 3) Camera
      const camera = new THREE.PerspectiveCamera(
        60, // 시야각(FOV: field of view)
        window.innerWidth / window.innerHeight, // aspect ration
        0.1, // 가까운 클리핑 거리
        1000 // 먼 클리핑 거리
      );
      camera.position.set(12, 10, 12);
      camera.lookAt(0, 0, 0);

      // 4) Controls (옵션)
      const controls = new OrbitControls(camera, renderer.domElement);
      controls.enableDamping = true;

      // 5) Lights
      const hemi = new THREE.HemisphereLight(0xffffff, 0x444444, 0.6);
      hemi.position.set(0, 50, 0);
      scene.add(hemi);

      // 방향광 + 그림자
      const dir = new THREE.DirectionalLight(0xffffff, 1.0);
      // DirectionalLight: 멀리 있는 태양처럼, 한 방향에서 전체 장면에 고르게 빛을 쏘는 광원
      // (흰색, 빛의 세기)
      dir.position.set(10, 20, 10);
      // 빛이 오는 방향을 설정.
      dir.castShadow = true;
      // 이 빛이 그림자를 만들도록 활성화
      dir.shadow.mapSize.set(2048, 2048);
      dir.shadow.camera.near = 0.5;
      dir.shadow.camera.far = 100;
      // 그림자를 계산할 카메라의 깊이 범위
      const s = 60; // 그림자 카메라 범위
      dir.shadow.camera.left = -s;
      dir.shadow.camera.right = s;
      dir.shadow.camera.top = s;
      dir.shadow.camera.bottom = -s;
      // 그림자 계산에 쓰이는 정사각형 카메라 영역 설정.
      // 이 영역 안에 있는 물체만 그림자 렌더링.
      // 너무 작으면 그림자가 잘리거나 안 보이고, 너무 크면 흐려짐.
      scene.add(dir);
      // Scene에 광원을 추가해 적용.

      // 6) Mesh: PlaneGeometry
      const W = 100,
        H = 100,
        SEGX = 400,
        SEGY = 400; // 해상도 적당히
      const geo = new THREE.PlaneGeometry(W, H, SEGX, SEGY);
      geo.rotateX(-Math.PI / 2);

      /*- 커스템 셰이더 머티리얼 -*/
      const mat = new THREE.ShaderMaterial({
        uniforms: {
          uScale: { value: 0.2 }, // 필드 스케일(주파수)
          uAmp: { value: 10.0 }, // 진폭
          uOctaves: { value: 8 }, // fBm 옥타브: 작은 디테일 누적
          uLacunarity: { value: 2.0 }, // 주파수 증가율
          uGain: { value: 0.5 }, // 진폭 감쇠율
          uLightDir: { value: new THREE.Vector3(0.6, 1.0, 0.5).normalize() },
          uGrow: { value: 0.0 },
          uRidgeOffset: { value: 0.9 }, // 능선 중심 오프셋 (0.8~1.2)
          uRidgeGain: { value: 1.6 }, // 옥타브 가중치 갱신에 쓰는 게인 (1.5~3.0)
          uRidgeSharp: { value: 1.6 }, // 능선 날카로움 지수 (1.0~3.0)
          uRidgeH: { value: 0.5 }, // 진폭 감쇠 세기(H≈1이면 amp가 옥타브마다 0.5배쯤 감소)
          uBias: { value: 0.5 }, // ridged 기본은 0.4~0.6 근처가 무난
          uWarpAmp: { value: 0.8 }, // 워핑 세기 (0.3~1.2)
          uRimGain: { value: 0.35 },
          uWarpScale: { value: 1.25 }, // 워핑 노이즈 스케일
          uWarpOctaves: { value: 2 }, // 2~4 권장
          uWarpLacunarity: { value: 2.0 },
          uWarpGain: { value: 0.5 },
          // PATCH START  (3) [JS: ShaderMaterial.uniforms 추가]
// 새 유니폼 기본값 세팅 (총 5개, 가드레일 준수)
uAScale:        { value: 0.2  },
uATerraceSteps: { value: 8.0  },
uBScale:        { value: 0.2  },
uBThreshLo:     { value: 0.40 },
uBThreshHi:     { value: 0.60 },
// PATCH END


          uHeightBlend: { value: 0.5 }, // 0=Billow, 1=Rigid (높이 블렌드)
          uWarpBlend: { value: 0.5 }, // 0=Billow warper, 1=Rigid warper (도메인 워프 블렌드)

          uH: { value: 1.0 }, // billow MF용
          uBillowSharp: { value: 1.25 },

          uMaskHeightLo: { value: 0.3 },
          uMaskHeightHi: { value: 0.8 },
          uMaskSlopeLo: { value: 0.3 },
          uMaskSlopeHi: { value: 0.55 },
          uColA: { value: new THREE.Color(0xeed9b7) }, // billow 쪽 모래빛 색
          uColB: { value: new THREE.Color(0x555566) }, // ridged 쪽 짙은 바위색
          uCenter: { value: 0.0 }, // ridged 베이스면 0.0
        },

        vertexShader: `
       
        precision highp float;
precision highp int;

    uniform float uScale, uAmp, uGrow;
    uniform int   uOctaves;
    uniform float uRimGain;
    uniform float uAScale;         // Terrace fBm scale
uniform float uATerraceSteps;  // Terrace step count
uniform float uBScale;         // OpenSimplex mask scale
uniform float uBThreshLo;      // Mask low threshold  [0,1]
uniform float uBThreshHi;      // Mask high threshold [0,1]
    uniform float uLacunarity, uGain;
    uniform float uRidgeOffset, uRidgeGain, uRidgeSharp, uRidgeH;
    uniform float uBias; 
    uniform float uWarpAmp, uWarpScale, uWarpLacunarity, uWarpGain;
    uniform int   uWarpOctaves;
    uniform float uMaskHeightLo, uMaskHeightHi;
    uniform float uH;             // ★ billow 옥타브 감쇠
uniform float uBillowSharp;   // ★ billow 둥근 정도

    varying vec3 vWorldPos;
    varying float vHeight;
    
        // === Simplex 2D (GLSL) ===
    vec3 mod289(vec3 x){ return x - floor(x * (1.0/289.0)) * 289.0; }
    vec2 mod289(vec2 x){ return x - floor(x * (1.0/289.0)) * 289.0; }
    vec3 permute(vec3 x){ return mod289(((x*34.0)+1.0)*x); }

    float snoise(vec2 v){
      const float C = 0.211324865405187; // (3.0-sqrt(3.0))/6.0 (G2)
      const float F = 0.366025403784439; // (sqrt(3.0)-1.0)/2.0 (F2)
      // Skew
      float s = (v.x+v.y)*F;
      vec2 i = floor(v + s);
      float t = (i.x + i.y) * C;
      vec2 X0 = i - t;
      vec2 x0 = v - X0;

      // Which triangle?
      vec2 i1 = (x0.x > x0.y) ? vec2(1.0,0.0) : vec2(0.0,1.0);
      vec2 x1 = x0 - i1 + C;
      vec2 x2 = x0 - 1.0 + 2.0*C;

      // Permutations
      i = mod289(i);
      vec3 p = permute( permute( i.y + vec3(0.0, i1.y, 1.0) )
                      + i.x + vec3(0.0, i1.x, 1.0) );

      // Gradients
      vec3 x = fract(p * (1.0/41.0)) * 2.0 - 1.0;
      vec3 h = abs(x) - 0.5;
      vec3 ox = floor(x + 0.5);
      vec3 a0 = x - ox;

      // Normalize gradients implicitly by dot(h,h)
      vec2 g0 = vec2(a0.x, h.x);
      vec2 g1 = vec2(a0.y, h.y);
      vec2 g2 = vec2(a0.z, h.z);

      // Kernels
      vec3 w = max(0.5 - vec3(dot(x0,x0), dot(x1,x1), dot(x2,x2)), 0.0);
      vec3 w4 = w*w*w*w;

      float n0 = dot(g0, x0);
      float n1 = dot(g1, x1);
      float n2 = dot(g2, x2);

      return 40.0 * dot(w4, vec3(n0,n1,n2)); // ~[-1,1]
    }

    // === 워핑 도우미 ===
float fbmN(vec2 p, int oct, float lac, float gain){
  float n=0.0, a=0.5, f=1.0;
  for(int o=0;o<12;o++){ if(o>=oct) break;
    n += snoise(p*f) * a;
    f *= lac; a *= gain;
  }
  return n;
}
vec2 warpVec(vec2 p){
  float x = fbmN(p + vec2(37.2,17.5), uWarpOctaves, uWarpLacunarity, uWarpGain);
  float y = fbmN(p + vec2(-12.9,78.1), uWarpOctaves, uWarpLacunarity, uWarpGain);
  return vec2(x,y);
}
vec2 applyWarp(vec2 p){
  vec2 q = p * uWarpScale;
  return p + uWarpAmp * warpVec(q);
}

// === 워핑 도우미 ===
vec2 applyWarpR(vec2 p){                // ridge 전용
  vec2 q = p * uWarpScale + vec2(53.2, 91.7);
  return p + uWarpAmp * warpVec(q);
}
vec2 applyWarpB(vec2 p){                // billow 전용
  vec2 q = p * (uWarpScale*0.92) + vec2(-17.9, 34.5);
  return p + uWarpAmp * warpVec(q);
}

float ridge(float n, float offset, float sharp){
  float r = offset - abs(n);
  return pow(max(r,0.0), sharp);
}

float ridgedMF(vec2 p, int oct, float lac, float gainParam,
               float offset, float sharp, float H){
  float sum=0.0, sumAmp=0.0, freq=1.0, amp=1.0, weight=1.0;
  for(int o=0;o<12;o++){
    if(o>=oct) break;
    float n = snoise(p*freq);
    float r = ridge(n, offset, sharp) * weight;
    sum    += r * amp;
    sumAmp += amp;
    weight = clamp(r * gainParam, 0.0, 1.0);
    freq  *= lac;
    amp   *= pow(lac, -H);
  }
  float v = sum / max(sumAmp, 1e-6);   // [0,1]
  return v*2.0 - 1.0;                  // [-1,1]
}

// billow 함수 (정점)
float billowMF(vec2 p, int oct, float lac, float H, float sharp){
  float sum=0.0, sumAmp=0.0, freq=1.0, amp=1.0;
  for(int o=0;o<12;o++){ if(o>=oct) break;
    float n = snoise(p*freq);
    float r = pow(abs(n), sharp);
    sum += r * amp; sumAmp += amp;
    freq *= lac; amp *= pow(lac, -H);
  }
  float v = sum / max(sumAmp, 1e-6);
  return v*2.0 - 1.0;
}
float fbm_simple(vec2 p, int oct, float lac, float gain){
  float n = 0.0, a = 0.5, f = 1.0;
  for(int o=0;o<12;o++){
    if(o>=oct) break;
    n += snoise(p*f) * a;          // snoise: [-1,1]
    f *= lac; a *= gain;
  }
  // n 대략 [-1,1] 근방으로 유지되도록 가중합
  return clamp(n, -1.0, 1.0);
}

// terrace: h([-1,1]) → t([-1,1])
float terrace(float h, float steps){
  float s = max(2.0, steps);
  float u = 0.5*h + 0.5;           // [-1,1] → [0,1]
  float t = floor(u*s)/s;          // 계단화
  return t*2.0 - 1.0;              // [0,1] → [-1,1]
}

// === genA/genB ===
// A 재료: Terrace fBm HEIGHT  (출력: [-1,1])
float genA(vec2 p){
  // branchA에서는 uWarp* 사용 금지 (가드레일)
  float h = fbm_simple(p, uOctaves, uLacunarity, uGain); // [-1,1]
  return terrace(h, uATerraceSteps);                     // [-1,1]
}

// B 재료: "OpenSimplex" MASK (근사: snoise 사용), 출력 [0,1]
// 필요 시 변환 명시: n([-1,1]) → m([0,1]) 후 smoothstep
float genB(vec2 p){
  float n = snoise(p);                 // [-1,1]
  float m = 0.5*n + 0.5;               // → [0,1]
  return smoothstep(uBThreshLo, uBThreshHi, m); // [0,1]
}

// === branchA/branchB 래퍼 (main에서 pos.xz 등을 넣어 호출) ===
float branchA_eval(vec2 p){ return genA(p * uAScale); }
float branchB_eval(vec2 p){ return genB(p * uBScale); }
// PATCH END

void main(){
  // PATCH START  [VERTEX void main 교체]
vec3 pos = position;
vec2 p   = pos.xz * uScale;
float A  = branchA(p); // HEIGHT[-1,1]
float B  = branchB(p); // MASK[0,1]
float h  = A + uRimGain * B; // 선택 공식
pos.y   += h * uAmp * uGrow;
vHeight  = h;
vec4 wp  = modelMatrix * vec4(pos,1.0);
vWorldPos= wp.xyz;
gl_Position = projectionMatrix * viewMatrix * wp;
// PATCH END
}
  `,
        fragmentShader: `
        precision highp float;
precision highp int;

        uniform vec3  uLightDir;
uniform float uScale, uAmp, uGrow;
uniform int   uOctaves;
uniform float uLacunarity, uGain;
uniform float uRidgeOffset, uRidgeGain, uRidgeSharp, uRidgeH;
uniform float uBias; 
uniform float uWarpAmp, uWarpScale, uWarpLacunarity, uWarpGain;
uniform int   uWarpOctaves;
uniform float uMaskHeightLo, uMaskHeightHi;
uniform float uMaskSlopeLo,  uMaskSlopeHi;
uniform vec3  uColA, uColB;
uniform float uH;
uniform float uAScale;
uniform float uATerraceSteps;
uniform float uBScale;
uniform float uBThreshLo;
uniform float uRimGain;
uniform float uBThreshHi;
uniform float uBillowSharp;
uniform float uCenter; 

    varying vec3 vWorldPos;
    varying float vHeight;

    // 동일 fBm을 프래그먼트에서도 호출해 높이 기울기→법선 근사
    vec3 mod289_vec3(vec3 x){ return x - floor(x*(1.0/289.0))*289.0; }
    vec2 mod289_vec2(vec2 x){ return x - floor(x*(1.0/289.0))*289.0; }
    vec3 permute_vec3(vec3 x){ return mod289_vec3(((x*34.0)+1.0)*x); }

    float snoise2(vec2 v){
      const float C = 0.211324865405187;
      const float F = 0.366025403784439;
      float s = (v.x+v.y)*F;
      vec2 i = floor(v + s);
      float t = (i.x + i.y) * C;
      vec2 X0 = i - t;
      vec2 x0 = v - X0;
      vec2 i1 = (x0.x > x0.y) ? vec2(1.0,0.0) : vec2(0.0,1.0);
      vec2 x1 = x0 - i1 + C;
      vec2 x2 = x0 - 1.0 + 2.0*C;
      i = mod289_vec2(i);
      vec3 p = permute_vec3( permute_vec3( i.y + vec3(0.0, i1.y, 1.0))
                           + i.x + vec3(0.0, i1.x, 1.0));
      vec3 x = fract(p * (1.0/41.0)) * 2.0 - 1.0;
      vec3 h = abs(x) - 0.5;
      vec3 ox = floor(x + 0.5);
      vec3 a0 = x - ox;
      vec2 g0 = vec2(a0.x, h.x);
      vec2 g1 = vec2(a0.y, h.y);
      vec2 g2 = vec2(a0.z, h.z);
      vec3 w = max(0.5 - vec3(dot(x0,x0), dot(x1,x1), dot(x2,x2)), 0.0);
      vec3 w4 = w*w*w*w;
      float n0 = dot(g0, x0);
      float n1 = dot(g1, x1);
      float n2 = dot(g2, x2);
      return 40.0 * dot(w4, vec3(n0,n1,n2));
    }

    // 워핑 도우미 (snoise2 버전)
float fbmN2(vec2 p, int oct, float lac, float gain){
  float n=0.0, a=0.5, f=1.0;
  for(int o=0;o<12;o++){ if(o>=oct) break;
    n += snoise2(p*f) * a;
    f *= lac; a *= gain;
  }
  return n;
}
vec2 warpVec2(vec2 p){
  float x = fbmN2(p + vec2(37.2,17.5), uWarpOctaves, uWarpLacunarity, uWarpGain);
  float y = fbmN2(p + vec2(-12.9,78.1), uWarpOctaves, uWarpLacunarity, uWarpGain);
  return vec2(x,y);
}
vec2 applyWarp2(vec2 p){
  vec2 q = p * uWarpScale;
  return p + uWarpAmp * warpVec2(q);
}

vec2 applyWarp2R(vec2 p){
  vec2 q = p * uWarpScale + vec2(53.2, 91.7);
  return p + uWarpAmp * warpVec2(q);   // ★ warpVec2 사용
}
vec2 applyWarp2B(vec2 p){
  vec2 q = p * (uWarpScale*0.92) + vec2(-17.9, 34.5);
  return p + uWarpAmp * warpVec2(q);   // ★ warpVec2 사용
}


    float ridge2(float n, float offset, float sharp){
  float r = offset - abs(n);
  r = max(r, 0.0);
  return pow(r, sharp);
}

float ridgedMF2(vec2 p, int oct, float lac, float gainParam,
                float offset, float sharp, float H){
  float sum=0.0, sumAmp=0.0, freq=1.0, amp=1.0, weight=1.0;
  for(int o=0;o<12;o++){
    if(o>=oct) break;
    float n = snoise2(p*freq);
    float r = max(offset - abs(n), 0.0);
    r = pow(r, sharp);
    r *= weight;
    sum    += r * amp;
    sumAmp += amp;
    weight = clamp(r * gainParam, 0.0, 1.0);
    freq *= lac;
    amp  *= pow(lac, -H);
  }
  float v = sum / max(sumAmp, 1e-6);
  return v * 2.0 - 1.0;
}

float billowMF2(vec2 p, int oct, float lac, float H, float sharp){
  float sum=0.0, sumAmp=0.0, freq=1.0, amp=1.0;
  for(int o=0;o<12;o++){
    if(o>=oct) break;
    float n = snoise2(p*freq);
    float r = abs(n);
    r = pow(r, sharp);
    sum    += r * amp;
    sumAmp += amp;
    freq *= lac;
    amp  *= pow(lac, -H);
  }
  float v = sum / max(sumAmp, 1e-6);
  return v*2.0 - 1.0;
} 
float fbm_simple2(vec2 p, int oct, float lac, float gain){
  float n = 0.0, a = 0.5, f = 1.0;
  for(int o=0;o<12;o++){
    if(o>=oct) break;
    n += snoise2(p*f) * a;         // snoise2: [-1,1]
    f *= lac; a *= gain;
  }
  return clamp(n, -1.0, 1.0);
}

float terrace2(float h, float steps){
  float s = max(2.0, steps);
  float u = 0.5*h + 0.5;           // [-1,1] → [0,1]
  float t = floor(u*s)/s;          // 계단화
  return t*2.0 - 1.0;              // [0,1] → [-1,1]
}

// === genA/genB (fragment) ===
float genA2(vec2 p){
  // branchA에서는 uWarp* 사용 금지
  float h = fbm_simple2(p, uOctaves, uLacunarity, uGain); // [-1,1]
  return terrace2(h, uATerraceSteps);                     // [-1,1]
}

float genB2(vec2 p){
  float n = snoise2(p);                // [-1,1]
  float m = 0.5*n + 0.5;               // → [0,1]
  return smoothstep(uBThreshLo, uBThreshHi, m); // [0,1]
}

// === branchA/branchB 래퍼 (main에서 vWorldPos.xz 등을 넣어 호출) ===
float branchA_eval2(vec2 p){ return genA2(p * uAScale); }
float branchB_eval2(vec2 p){ return genB2(p * uBScale); }
// PATCH END

void main(){
  float eps = 0.2;

  vec2 pC_R = applyWarp2R(vWorldPos.xz * uScale);
  vec2 pC_B = applyWarp2B(vWorldPos.xz * uScale);
  vec2 pX_R = applyWarp2R((vWorldPos.xz + vec2(eps,0.0)) * uScale);
  vec2 pX_B = applyWarp2B((vWorldPos.xz + vec2(eps,0.0)) * uScale);
  vec2 pZ_R = applyWarp2R((vWorldPos.xz + vec2(0.0,eps)) * uScale);
  vec2 pZ_B = applyWarp2B((vWorldPos.xz + vec2(0.0,eps)) * uScale);

  // --- 샘플링 ---
float hC = (branchA2(vWorldPos.xz * uScale) + uRimGain * branchB2(vWorldPos.xz * uScale)) * uAmp * uGrow;
float eps = 0.2; // 이미 있으면 재선언하지 말 것
float hX = (branchA2((vWorldPos.xz + vec2(eps, 0.0)) * uScale) + uRimGain * branchB2((vWorldPos.xz + vec2(eps, 0.0)) * uScale)) * uAmp * uGrow;
float hZ = (branchA2((vWorldPos.xz + vec2(0.0, eps)) * uScale) + uRimGain * branchB2((vWorldPos.xz + vec2(0.0, eps)) * uScale)) * uAmp * uGrow;
vec3 dX = vec3(eps, hX - hC, 0.0);
vec3 dZ = vec3(0.0, hZ - hC, eps);
vec3 N  = normalize(cross(dZ, dX));

// --------------------
// 블렌드 가중치 (고도/경사 기반)
float r01C = clamp(0.5*(hR_C + 1.0), 0.0, 1.0);
float b01C = clamp(0.5*(hB_C + 1.0), 0.0, 1.0);

// 1. 높이 마스크: ridge = 높은 곳, valley = 낮고 둥근 곳
float mRidge = smoothstep(0.6, 0.8, r01C);
float mValley = 1.0 - smoothstep(0.35, 0.35, b01C);

// slope 계산은 한 번만
vec3 dX = vec3(eps, (hB_X-hB_C) - (hR_X-hR_C), 0.0);
vec3 dZ = vec3(0.0, (hB_Z-hB_C) - (hR_Z-hR_C), eps);
vec3 N  = normalize(cross(dZ, dX));

float slopeVal = 1.0 - abs(dot(N, vec3(0.0,1.0,0.0)));
float mSlope = smoothstep(0.35, 0.65, slopeVal);

// 최종 마스크
float m = clamp(0.45 * mRidge + 0.5 * (1.0 - mSlope) * mValley, 0.0, 1.0);
m = pow(m, 0.95);

// 최종 높이
float hC = mix(hB_C, hR_C, m) * uAmp * uGrow;

// 최종 색
vec3 baseCol = mix(uColA, uColB, m);
float diff = clamp(dot(N, normalize(uLightDir)), 0.0, 1.0);
float ambient = 0.7;
vec3 col = baseCol * (ambient + (1.0 - ambient) * diff);
gl_FragColor = vec4(col, 1.0);
  }
  `,
      });

      const ground = new THREE.Mesh(geo, mat);
      ground.castShadow = true;
      ground.receiveShadow = true;
      scene.add(ground);

      // 깊이 패스에도 동일 변위 주입
      const depthMat = new THREE.MeshDepthMaterial({
        depthPacking: THREE.RGBADepthPacking,
      });
      depthMat.onBeforeCompile = (shader) => {
        const glsl = `

    vec3 mod289(vec3 x){ return x - floor(x*(1.0/289.0))*289.0; }
    vec2 mod289(vec2 x){ return x - floor(x*(1.0/289.0))*289.0; }
    vec3 permute(vec3 x){ return mod289(((x*34.0)+1.0)*x); }

    float snoise(vec2 v){
      const float C=0.211324865405187; const float F=0.366025403784439;
      float s=(v.x+v.y)*F; vec2 i=floor(v+s); float t=(i.x+i.y)*C;
      vec2 X0=i - t; vec2 x0=v - X0;
      vec2 i1=(x0.x>x0.y)?vec2(1.0,0.0):vec2(0.0,1.0);
      vec2 x1=x0 - i1 + C; vec2 x2=x0 - 1.0 + 2.0*C;
      i=mod289(i);
      vec3 p=permute( permute(i.y+vec3(0.0,i1.y,1.0)) + i.x+vec3(0.0,i1.x,1.0));
      vec3 x=fract(p*(1.0/41.0))*2.0-1.0; vec3 h=abs(x)-0.5; vec3 ox=floor(x+0.5); vec3 a0=x-ox;
      vec2 g0=vec2(a0.x,h.x), g1=vec2(a0.y,h.y), g2=vec2(a0.z,h.z);
      vec3 w=max(0.5-vec3(dot(x0,x0),dot(x1,x1),dot(x2,x2)),0.0); vec3 w4=w*w*w*w;
      float n0=dot(g0,x0), n1=dot(g1,x1), n2=dot(g2,x2);
      return 40.0*dot(w4, vec3(n0,n1,n2));
    }

    float fbmN(vec2 p, int oct, float lac, float gain){
  float n=0.0, a=0.5, f=1.0;
  for(int o=0;o<12;o++){ if(o>=oct) break; n+=snoise(p*f)*a; f*=lac; a*=gain; }
  return n;
}
vec2 warpVec(vec2 p){
  float x = fbmN(p + vec2(37.2,17.5), uWarpOctaves, uWarpLacunarity, uWarpGain);
  float y = fbmN(p + vec2(-12.9,78.1), uWarpOctaves, uWarpLacunarity, uWarpGain);
  return vec2(x,y);
}
vec2 applyWarp(vec2 p){
  vec2 q = p * uWarpScale;
  return p + uWarpAmp * warpVec(q);
}
    float ridge(float n, float offset, float sharp){
      float r = offset - abs(n);
      r = max(r, 0.0);
      return pow(r, sharp);
    }

    float ridgedMF(vec2 p, int oct, float lac, float gainParam,
                   float offset, float sharp, float H){
      float sum=0.0, freq=1.0, amp=1.0, weight=1.0;
      float sumAmp=0.0;
      for(int o=0;o<12;o++){
    if(o>=oct) break;
    float n = snoise(p*freq);
    float r = offset - abs(n);
    r = max(r, 0.0);
    r = pow(r, sharp);
    r *= weight;
    sum += r * amp;
    sumAmp += amp;                 // ★ 진폭 누적
    weight = clamp(r * gainParam, 0.0, 1.0);
    freq *= lac;
    amp  *= pow(lac, -H);
  }
      float v = sum / max(sumAmp, 1e-5); 
      return sum*2.0 - 1.0;
    }

    float billowMF(vec2 p, int oct, float lac, float H, float sharp){
  float sum=0.0, sumAmp=0.0, freq=1.0, amp=1.0;
  for(int o=0;o<12;o++){
    if(o>=oct) break;
    float n = snoise(p*freq);
    float r = pow(abs(n), sharp);
    sum    += r * amp;
    sumAmp += amp;
    freq *= lac; amp *= pow(lac, -H);
  }
  float v = sum / max(sumAmp, 1e-6);
  return v*2.0 - 1.0;
}

float fbm_simple(vec2 p, int oct, float lac, float gain){
  float n = 0.0, a = 0.5, f = 1.0;
  for(int o=0;o<12;o++){
    if(o>=oct) break;
    n += snoise(p*f) * a;          // snoise: [-1,1]
    f *= lac; a *= gain;
  }
  // n 대략 [-1,1] 근방으로 유지되도록 가중합
  return clamp(n, -1.0, 1.0);
}

// terrace: h([-1,1]) → t([-1,1])
float terrace(float h, float steps){
  float s = max(2.0, steps);
  float u = 0.5*h + 0.5;           // [-1,1] → [0,1]
  float t = floor(u*s)/s;          // 계단화
  return t*2.0 - 1.0;              // [0,1] → [-1,1]
}

// === genA/genB ===
// A 재료: Terrace fBm HEIGHT  (출력: [-1,1])
float genA(vec2 p){
  // branchA에서는 uWarp* 사용 금지 (가드레일)
  float h = fbm_simple(p, uOctaves, uLacunarity, uGain); // [-1,1]
  return terrace(h, uATerraceSteps);                     // [-1,1]
}

// B 재료: "OpenSimplex" MASK (근사: snoise 사용), 출력 [0,1]
// 필요 시 변환 명시: n([-1,1]) → m([0,1]) 후 smoothstep
float genB(vec2 p){
  float n = snoise(p);                 // [-1,1]
  float m = 0.5*n + 0.5;               // → [0,1]
  return smoothstep(uBThreshLo, uBThreshHi, m); // [0,1]
}

// === branchA/branchB 래퍼 (main에서 pos.xz 등을 넣어 호출) ===
float branchA_eval(vec2 p){ return genA(p * uAScale); }
float branchB_eval(vec2 p){ return genB(p * uBScale); }
// PATCH END
    `;

        // ★ uniforms 바인딩
        shader.uniforms.uScale = mat.uniforms.uScale;
        shader.uniforms.uAmp = mat.uniforms.uAmp;
        shader.uniforms.uOctaves = mat.uniforms.uOctaves;
        shader.uniforms.uLacunarity = mat.uniforms.uLacunarity;
        shader.uniforms.uRidgeGain = mat.uniforms.uRidgeGain;
        shader.uniforms.uRidgeOffset = mat.uniforms.uRidgeOffset;
        shader.uniforms.uRidgeSharp = mat.uniforms.uRidgeSharp;
        shader.uniforms.uGrow = mat.uniforms.uGrow;
        shader.uniforms.uRidgeH = mat.uniforms.uRidgeH;
        shader.uniforms.uBias = mat.uniforms.uBias;
        shader.uniforms.uRimGain = mat.uniforms.uRimGain;
        shader.uniforms.uAScale        = mat.uniforms.uAScale;
shader.uniforms.uATerraceSteps = mat.uniforms.uATerraceSteps;
shader.uniforms.uBScale        = mat.uniforms.uBScale;
shader.uniforms.uBThreshLo     = mat.uniforms.uBThreshLo;
shader.uniforms.uBThreshHi     = mat.uniforms.uBThreshHi;

        shader.uniforms.uWarpAmp = mat.uniforms.uWarpAmp;
        shader.uniforms.uWarpScale = mat.uniforms.uWarpScale;
        shader.uniforms.uWarpOctaves = mat.uniforms.uWarpOctaves;
        shader.uniforms.uWarpLacunarity = mat.uniforms.uWarpLacunarity;
        shader.uniforms.uWarpGain = mat.uniforms.uWarpGain;
        shader.uniforms.uMaskHeightLo = mat.uniforms.uMaskHeightLo;
        shader.uniforms.uMaskHeightHi = mat.uniforms.uMaskHeightHi;
        shader.uniforms.uH = mat.uniforms.uH;
        shader.uniforms.uBillowSharp = mat.uniforms.uBillowSharp;

        shader.vertexShader = shader.vertexShader
          .replace(
            "#include <common>",
            `#include <common>
              
              precision highp float;
precision highp int;

       uniform float uScale,uAmp,uGrow;
       uniform int   uOctaves;
       uniform float uLacunarity;
       uniform float uRidgeGain,uRidgeOffset,uRidgeSharp;
uniform float uWarpAmp, uWarpScale, uWarpLacunarity, uWarpGain;
uniform int   uWarpOctaves;
uniform float uMaskHeightLo, uMaskHeightHi;  
uniform float uH, uBillowSharp;  
uniform float uRidgeH; 
uniform float uAScale;         // Terrace fBm scale
uniform float uATerraceSteps;  // Terrace step count
uniform float uBScale;         // OpenSimplex mask scale
uniform float uBThreshLo;      // Mask low threshold  [0,1]
uniform float uBThreshHi;      // Mask high threshold [0,1]  
uniform float uRimGain;
// PATCH END

       ${glsl}`
          )
          .replace(
            "#include <begin_vertex>",
            `
            vec3 transformed = vec3(position);
vec2 p  = transformed.xz * uScale;
float A = branchA(p); // [-1,1]
float B = branchB(p); // [0,1]
float h = A + uRimGain * B;
transformed.y += h * uAmp * uGrow;

`
          );
      };

      ground.customDepthMaterial = depthMat;

      /* 원본 정점 좌표 캐시: (x, y, z) 반복 */
      const posAttr = geo.attributes.position;
      const base = new Float32Array(posAttr.array.length);
      base.set(posAttr.array);

      /* Simplex Noise */
      /* [STEP 1] 정수 격자(integer lattice): 입력 좌표를 floor 해서 해당 칸과 주변 격자점을 기준으로 계산한다.*/
      function latticeFloor(v) {
        return Math.floor(v);
      }

      /* [STEP 2] 격자점마다 난수로 생성된 gradient vector: '선별 팔레트'에서 해시 선택 (축 편향/클러핑 완화 & 연산 경량화) */
      /* 8방향 팔레트(정규화): (±1,0), (0,±1), (±1,±1) */
      const G8 = [
        [1, 0],
        [-1, 0],
        [0, 1],
        [0, -1],
        [1, 1],
        [-1, 1],
        [1, -1],
        [-1, -1],
      ].map(([x, y]) => {
        const L = Math.hypot(x, y);
        return [x / L, y / L];
      });

      // 가벼운 정수 해시 → 0..7 (좌표 기반 고정 난수 인덱스)
      function hash2(i, j) {
        let h = i * 374761393 + j * 668265263;
        h = (h ^ (h >>> 13)) * 1274126177;
        return (h ^ (h >>> 16)) & 7;
      }
      const grad2 = (i, j) => G8[hash2(i, j)];
      const dot2 = (a, b) => a[0] * b[0] + a[1] * b[1];

      // Skew/Unskew 상수 (2D)
      const F2 = 0.5 * (Math.sqrt(3) - 1); // ≈ 0.366025403
      const G2 = (3 - Math.sqrt(3)) / 6; // ≈ 0.211324865

      // 2D Simplex noise
      function simplex2D(x, y) {
        // Skew: 정사각형 격자를 심플렉스 좌표계로 기울여서 "정수 셀"을 쉽게 찾음
        const s = (x + y) * F2;
        const i = Math.floor(x + s);
        const j = Math.floor(y + s);

        // Unskew: 다시 원래 좌표계로 복원 (셀의 원점 X0,Y0)
        const t = (i + j) * G2;
        const X0 = i - t,
          Y0 = j - t;
        const x0 = x - X0,
          y0 = y - Y0; // 셀 내부 상대 좌표

        // 어떤 삼각형 절반에 있는지: (1,0) or (0,1)
        let i1, j1;
        if (x0 > y0) {
          i1 = 1;
          j1 = 0;
        } else {
          i1 = 0;
          j1 = 1;
        }

        // 세 코너까지의 상대 좌표
        const x1 = x0 - i1 + G2;
        const y1 = y0 - j1 + G2;
        const x2 = x0 - 1 + 2 * G2;
        const y2 = y0 - 1 + 2 * G2;

        // 각 코너의 gradient
        const g0 = grad2(i, j);
        const g1 = grad2(i + i1, j + j1);
        const g2v = grad2(i + 1, j + 1);

        // 감쇄 커널 t^4 * (grad · dist)
        let n0 = 0,
          n1 = 0,
          n2 = 0;

        let tt0 = 0.5 - x0 * x0 - y0 * y0;
        if (tt0 > 0) {
          tt0 *= tt0;
          n0 = tt0 * tt0 * dot2(g0, [x0, y0]);
        }

        let tt1 = 0.5 - x1 * x1 - y1 * y1;
        if (tt1 > 0) {
          tt1 *= tt1;
          n1 = tt1 * tt1 * dot2(g1, [x1, y1]);
        }

        let tt2 = 0.5 - x2 * x2 - y2 * y2;
        if (tt2 > 0) {
          tt2 *= tt2;
          n2 = tt2 * tt2 * dot2(g2v, [x2, y2]);
        }

        // 2D 정규화 상수(대략 70)를 곱해 [-1,1] 근방으로 스케일링
        return 70.0 * (n0 + n1 + n2);
      }

      // 7) Resize handler
      window.addEventListener("resize", () => {
        // 브라우저 창 크기가 변경될 때마다 안쪽 함수를 실행.
        const w = window.innerWidth,
          h = window.innerHeight; // 현재 브라우저 창의 너비와 높이를 가져옴.
        camera.aspect = w / h; // 카메리의 aspect ration를 새 창 비율에 맞게 갱신.
        camera.updateProjectionMatrix(); // 카메라 설정이 바뀌었으니, 내부 행렬 다시 계싼
        renderer.setSize(w, h); // 렌더러의 캔버스 크기를 새 창 크기에 맞춰 조정.
      });

      const clock = new THREE.Clock();
      function animate() {
        const dt = clock.getDelta();
        // 0 → 1로 서서히 (속도는 필요에 맞게)
        mat.uniforms.uGrow.value = Math.min(
          1.0,
          mat.uniforms.uGrow.value + dt * 0.5
        );
        controls.update();
        renderer.render(scene, camera);
        requestAnimationFrame(animate);
      }
      animate();
    </script>
    <!-- three.js 보일러플레이트 끝 -->
  </body>
</html>
